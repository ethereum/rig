{
    "componentChunkName": "component---node-modules-lekoarts-gatsby-theme-jodie-core-src-templates-project-query-tsx",
    "path": "/blog/vdf-proving-with-snark-pack",
    "result": {"data":{"project":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"VDF Proving with SnarkPack\",\n  \"shortTitle\": \"SnarkPack VDF\",\n  \"category\": \"Still\",\n  \"color\": \"white\",\n  \"cover\": \"./vdfsnail.jpeg\",\n  \"date\": \"2021-07-16\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"VDF Proving with SnarkPack\"), mdx(\"p\", null, \"Verifiable delay functions are a core building block to the Eth2 infrastructure.  They assume the existence of a deterministic function \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" such that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f(x) = y\"), \" takes at least time \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"t\"), \" to compute.  They further require a short proof \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi\"), \" attesting to the fact that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f(x)\"), \" has been computed correctly.  This is to allow for fast verification.\"), mdx(\"p\", null, \"The purpose of this document is to discuss how SnarkPack can be used to generate the proof \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi\"), \". Other options include using hidden order groups such  as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2018/623.pdf\"\n  }, \"1\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2018/627.pdf\"\n  }, \"2\"), \", \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/starkware-libs/veedo/tree/72814c2052d80f97f3a7300160051b71e6810893\"\n  }, \"STARKs\"), \", or recursive SNARKs such as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2019/1021.pdf\"\n  }, \"Halo\"), \".  The code relating to this post can be found \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/mmaller/vdf_snark\"\n  }, \"here\"), \".\"), mdx(\"p\", null, \"At a high level, the function  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" is iterative and essentially computes the same smaller function over and over again: so \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"F(x) = f( f( f( f( ... )))) = y\"), \". We can prove with a general purpose Snark that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"F(x) = y\"), \" directly.  However, this is expensive to do, to the point where proving correct computation of the function takes many times longer than the computation itself, even using the best hardware and a high degree of parallelism.  Our idea instead is to prove with a Groth16 Snark that e.g. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f(f(f(x_1))) = x_2\"), \", and then that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f(f(f(x_2))) = x_3\"), \", and continue until enough iterations of the function have been computed.  This presents two advantages: (1) the computation of f(f(f(x))) is much smaller that the computation of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"F(X)\"), \" so the Groth16 prover is much easier to parallelise; (2) we can begin computing a proof for \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f(f(f(x)))\"), \" before we know the full outcome \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"F(x) = y\"), \".  Once we have our numerous \\\"in between\\\" proofs, we can then aggregate these using SnarkPack into one small proof for the entire computation.  SnarkPack is already heavily parellelised and so our aggregator can take advantage of this.\"), mdx(\"p\", null, \"SnarkPack has the following advantages for a VDF proof:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The aggregation prover is concretely very fast.  Thus it does not present a  bottleneck even though it can only be computed after the full computation is complete.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The prover is easy to parellise.  The prover can first compute F(x) by keeping the intermediate results and compute in parallel all the Groth16 proofs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The majority of intermediary results do not need to be stored meaning that the approach is memory efficient.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The verifier is succinct and runs in time \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathcal{O}(\\\\log(\\\\frac{n}{t}))\"), \" where \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"n\"), \" is the total number of iterations of \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" and \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"t\"), \" is the number of iterations of \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" ran inside each Groth16 proof.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The proof size is succinct and equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathcal{O}(\\\\log(\\\\frac{n}{t}))\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There already exist high quality implementations of Groth16.\")), mdx(\"p\", null, \"SnarkPack has the following disadvantages for a VDF proof:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The proof consists of target group elements, and the verifier must compute target group exponentiations.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Groth16 proofs require a trusted setup.   We would need to gather a set of at least 100 participants, but preferably more like 1000 to take part.  Coordinating trusted setups has been done before by Zcash, Aztec, Celo, Filecoin, Perpetual Powers of Tau and some others.  Thus we know that it is possible but that it is unlikely to be easy.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Groth16 trusted setup is circuit specific therefore we must be certain of our constraints before it is run, and we will not be able to make changes after it has been run.  Potentially the damage of this downside is limitted in our sloth application because the specialist hardware is already circuit specific.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The solution is not quantum safe.\")), mdx(\"h2\", null, \"Technical\"), mdx(\"p\", null, \"We use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/khovratovich/MinRoot\"\n  }, \"MinRoot\"), \" function by Feist and Khovratovich.  Other candidates include the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2015/366.pdf\"\n  }, \"original Sloth function\"), \" by Lenstra and Wesolowski, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2018/601.pdf\"\n  }, \"Sloth++\"), \" by Boneh et al., and Veedo by Starkware.  Note that the original MinRoot suggestion computed cube-roots.  We compute fifth-roots because in the field Fr of BLS12-381 the cube-root does not always exist.\"), mdx(\"p\", null, \"In the MinRoot VDF we have that a single iteration of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" is given by\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"f(x_i, y_i) = ((x_i + y_i)^{1/5}, x_i)\"), mdx(\"p\", null, \"Then the MinRoot VDF computes \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" over \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"n\"), \" iterations where each new iteration takes as input the result of the previous iteration.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"minroot(x_0, y_0):\\n    for i in 0..n:\\n        (x_{i+1}, y_{i+1}) = ((x_i + y_i)^{1/5}, x_i) mod p\\n    return (x_n, y_n)\\n\")), mdx(\"h3\", null, \"Proving with Groth16\"), mdx(\"p\", null, \"We prove that minroot has been correctly computed using Groth16 implemented over BLS381-12.  To do this we must encode minroot into the R1CS constraint system.\"), mdx(\"h4\", null, \"Constraint System\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Public Inputs:\"), \" We take as public inputs \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_0, y_0, x_n, y_n)\"), \" where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_0, y_0)\"), \" are the first inputs to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_n, y_n)\"), \" are the final outputs of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \".\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Constraints:\"), \" We prove the following constraints:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The first witness value is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"x_0\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The second witness value is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"y_0\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The penultimate witness value is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"x_n\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The final witness value is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"y_n\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"0 < i < n\"), \", a temporary witness value \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{tmp2}_{i}\"), \" is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"x_{i+1}^2\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"0 < i < n\"), \", a temporary witness value \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{tmp3}_{i}\"), \" is equal to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{tmp2}_{i}^2\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"For \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"0 < i < n\"), \", we have that \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"(x_i + y_i) = x_{i+1} * \\\\mathsf{tmp3}_{i}\"), \".\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Efficiency:\"), \" Our encoding requires \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"3n + 4\"), \" constraints where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"n\"), \" is the number of iterations of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \".  There are \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"5\"), \" public inputs (including an initial public input that is always set to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"1\"), \").\"), mdx(\"h4\", null, \"Efficiency\"), mdx(\"p\", null, \"Using (a fork of) the Bellman library in rust we run the Groth16 prover on an Intel Core i5 with 2.3 GHz using \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"n = 10000\"), \".  We find that the computation of minroot took on average \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"106\"), \" milliseconds over \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"128\"), \" trials.  In comparison the computation of the Groth16 proof toook on average \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"1345\"), \" milliseconds.  Thus it took \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"12.7\"), \" times longer to prove than to compute.  We will not make any meaningful conclusions from these numbers because they do not indicate the performance of specialist hardware.\"), mdx(\"h3\", null, \"Aggregating with SnarkPack\"), mdx(\"p\", null, \"From our Groth16 provers, we obtain a list of inputs, outputs, and proofs of the form\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"[(1, x_0, y_0, x_1, y_1), \\\\pi_0],\\n[(1, x_1, y_1, x_2, y_2), \\\\pi_1],\\n\\\\ldots,\\n[(1, x_{m-1}, y_{m-1}, x_m, y_m), \\\\pi_{m-1}]\"), mdx(\"p\", null, \"where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_i\"), \" is a Groth16 proof attesting to the correctness of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_{i+1}, y_{i+1}) = \\\\mathsf{minroot}(x_i, y_i)\"), \". In other words \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_{i+1}, y_{i+1})\"), \" is the result of applying \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"n\"), \" iterations of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_i, y_i)\"), \".\"), mdx(\"p\", null, \"Denoting the instances by\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"(1, a_0, b_0, c_0, d_0), \\\\ldots, (1, a_{m-1}, b_{m-1}, c_{m-1}, d_{m-1})\"), mdx(\"p\", null, \"we have the VDF evaluation is correct if and only if the following constraints hold\"), mdx(\"p\", null, \"1) The first \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(a_0, b_0)\"), \" are exactly equal to the public input of the VDF (x\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"0, y_0).\\n2) The last $(c\"), \"{m-1}, d\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"{m-1})$ are exactly equal to the public output of the VDF \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"math math-inline\"\n  }, \"(x_m, y_m)\"), \".\\n3) It is true that \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"math math-inline\"\n  }, \"(c_j, d_j) = \\\\mathsf{minroot}(a_j,b_j)\"), \"\\n4) The \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"math math-inline\"\n  }, \"jth\"), \" output \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"math math-inline\"\n  }, \"(c_j , d_j)\"), \" is equal to the \", mdx(\"span\", {\n    parentName: \"em\",\n    \"className\": \"math math-inline\"\n  }, \"(j+1)th\"), \" input $(a\"), \"{j+1}, b_{j+1})$.\"), mdx(\"p\", null, \"The proofs \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(\\\\pi_{0}, \\\\ldots, \\\\pi_{m-1})\"), \" attest to the fact that the third point holds.  We look to aggregate the proofs using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2021/529.pdf\"\n  }, \"SnarkPack\"), \". Denote \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_j = (A_j, B_j, C_j)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_{AB} = \\\\prod_{j=0}^{m-1} e(A_j^{r^j},  B_j)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_C = \\\\prod_{j=0}^{m-1} C_j^{r^j}\"), \" for some random value \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \"  determined after \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"[(x_0, y_0, x_1, y_1), \\\\pi_0]\"), \", \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\ldots\"), \", \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"[(x_{m-1}, y_{m-1}, x_m, y_m), \\\\pi_{m-1}]\"), \" have been fixed.  The proof \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{agg}}\"), \" attests to the fact that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_{AB}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_C\"), \" have been computed correctly.  The proof \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{agg}}\"), \" is of size \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathcal{O}(\\\\log(n))\"), \" and can be verified using \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathcal{O}(\\\\log(n))\"), \" target group exponentiations.\"), mdx(\"p\", null, \"We then have that the Groth16 verifier is satisfied if and only if\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"EQ_1: \\\\quad Z_{AB} = e(g^{\\\\alpha \\\\left(\\\\sum_{j=0}^{m-1} r^j \\\\right)}, h^{\\\\beta}) e(\\\\prod_{k = 0}^{\\\\ell} S_k^{\\\\sum_{j=0}^{m-1} a_{j,k} r^j}, h^{\\\\gamma}) e(Z_C, h^{\\\\delta})\"), mdx(\"h3\", null, \"Handling Public Inputs to SnarkPack\"), mdx(\"p\", null, \"From our SnarkPack prover, we obtain a list of inputs, outputs and aggregated proofs of the form\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"[(x_0, y_0, x_1, y_1)],\\n[(x_1, y_1, x_2, y_2)],\\n\\\\ldots,\\n[(x_{m-1}, y_{m-1}, x_m, y_m)], Z_{AB}, Z_C, \\\\pi_{\\\\mathsf{agg}}\"), mdx(\"p\", null, \"where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{agg}}\"), \" attests to the correctness of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_{AB}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_C\"), \".  This still has size \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathcal{O}(m)\"), \" due to the inclusion of the instance values.  We now look to avoid giving out the intermediary values\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"(x_1, y_1), \\\\ldots, (x_{m-1}, y_{m-1})\"), mdx(\"p\", null, \"in order to achieve logarithmic costs.  However our verifier must remain confident that there exists such intermediary values satisfying our security requirements 1, 2, 3, and 4.\"), mdx(\"p\", null, \"To do this we define the polynomials\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"p(X) = x_0 + x_1 X + \\\\cdots + x_{m-1} X^{m-1}\"), mdx(\"p\", null, \"and\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"q(X) = y_0 + y_1 X + \\\\cdots + y_{m-1} X^{m-1}\"), mdx(\"p\", null, \" according to the public instances and publicly give out the values\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"z_1 = \\\\sum_{j=0}^{m-1} x_{j} r^j = p(r)\\n\\\\quad \\\\mbox{and} \\\\quad\\nz_2 = \\\\sum_{j=0}^{m-1} y_{j} r^j = q(r)\"), mdx(\"p\", null, \"We design a constant sized proof \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{inputs}}\"), \" (which we will describe shortly) that attests  that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_1\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_2\"), \" have been computed correctly.  In other words it will enforce that p(X) is a degree \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"m-1\"), \" polynomial with \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"x_0\"), \" as the zero'th coefficient and that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" is a degree \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(m-1)\"), \" with \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"y_0\"), \" as the zero'th coefficient.\"), mdx(\"p\", null, \"To enforce that the last \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(c_{m-1}, d_{m-1})\"), \" are exactly equal to the public output of the VDF  and that the \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"jth\"), \" output \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(c_j , d_j)\"), \" is equal to the \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(j+1)th\"), \" input \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(a_{j+1}, b_{j+1})\"), \", we have the verifier compute\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"z_3 = \\\\sum_{j=0}^{m-1} x_{j+1} r^j = p(r)\\n\\\\quad \\\\mbox{and} \\\\quad\\nz_4 = \\\\sum_{j=0}^{m-1} y_{j + 1} r^j = q(r)\"), mdx(\"p\", null, \"for itself.  It can do this using the information \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(z_1, z_2, x_m, y_m)\"), \" because \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_3\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_4\"), \" are a shift of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(r)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(r)\"), \" respectively.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Prover\"), \" Then the VDF proof consists of the values\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"(x_0, y_0), (x_m, y_m), Z_{AB}, Z_C, z_1, z_2,\\\\pi_{\\\\mathsf{agg}}, \\\\pi_{\\\\mathsf{inputs}}\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Verifier:\"), \" The VDF verifier checks that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{agg}}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{inputs}}\"), \" both verify and then computes two additional values\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"z_3 = \\\\frac{1}{r}(z_1 - x_0) + r^{m-1} x_m\\n\\\\quad \\\\mbox{ and } \\\\quad\\nz_4 = \\\\frac{1}{r}(z_2 - y_0) + r^{m-1} y_m\"), mdx(\"p\", null, \"It then sets \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r_{\\\\mathsf{sum}} =  \\\\sum_{j=0}^{m-1} r^j = \\\\frac{r^m - 1}{r - 1}\"), \" and checks that\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"Z_{AB} = e(g^{\\\\alpha r_{\\\\mathsf{sum}} }, h^{\\\\beta}) e( S_0^{r_{\\\\mathsf{sum}}} S_1^{z_1}S_2^{z_2}S_3^{z_3}S_4^{z_4}, h^{\\\\gamma}) e(Z_C, h^{\\\\delta})\"), mdx(\"p\", null, \"The verifier returns true if and only if all checks pass.  See that the verifiers equation corresponds exactly to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"EQ_1\"), \".\"), mdx(\"h4\", null, \"Proving Correct Inputs\"), mdx(\"p\", null, \"To prove that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_1\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_2\"), \" are computed correctly we will use the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf\"\n  }, \"KZG10 polynomial commitment\"), \" scheme.  The techniques used here are  similar to  those by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://eprint.iacr.org/2021/627.pdf\"\n  }, \" Tyagi et al.\"), \".  We set a polynomial commitment to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(X)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" as\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"\\\\mathsf{com}_p = g^{ \\\\sum_{j=0}^{m-1} x_j \\\\tau^j} \\\\quad \\\\mbox{ and } \\\\quad \\\\mathsf{com}_q = g^{ \\\\sum_{j=0}^{m-1} y_j \\\\tau^j}\"), mdx(\"p\", null, \"where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\tau\"), \" is secret.\"), mdx(\"p\", null, \"The commitments \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" must be chosen before the randomness \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \" used to compute \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_{AB}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"Z_C\"), \" is selected. This is to ensure that the polynomials \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(X)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" cannot  depend on \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \", which is equivalent to ensuring that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"(x_0, y_0, x_1, y_1), \\\\ldots, (x_{m-1}, y_{m-1}, x_m, y_m)\"), \" are fixed before \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \" is determined.  We thus include \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" in the Fiat-Shamir hash that is used to compute \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \".\"), mdx(\"p\", null, \"The prover now needs to show that\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" has zero coefficient \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"x_0\"), \" and \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" has zero coefficient \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"y_0\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" and \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" both have degree no higher than \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"m-1\"), \".\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" evaluates at \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \" to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"z_1\"), \" and \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" evaluates at \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \"  to \", mdx(\"span\", {\n    parentName: \"li\",\n    \"className\": \"math math-inline\"\n  }, \"z_2\"), \".\")), mdx(\"p\", null, \"To prove that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" has zero coefficient \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"x_0\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" has zero coefficient \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"y_0\"), \", the prover include values \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{p,0}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{q,0}\"), \" equal to\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"W_{p,0} = g^{ \\\\sum_{j=1}^{m-1} x_j \\\\tau^{j-1}} \\\\quad \\\\mbox{ and } \\\\quad W_{q,0} = g^{ \\\\sum_{j=1}^{m-1} y_j \\\\tau^{j-1}}.\"), mdx(\"p\", null, \"The verifier checks  that\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \" e(\\\\mathsf{com}_p  \\\\cdot g^{-x_0}, h) = e(W_{p,0}, h^{\\\\tau})\\n\\\\quad \\\\mbox{ and }  \\\\quad e(\\\\mathsf{com}_q  \\\\cdot g^{-y_0}, h) = e(W_{q,0}, h^{\\\\tau}).\"), mdx(\"p\", null, \"If these checks hold but \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"x_0\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"y_0\"), \" are not the zero'th coefficients of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(X)\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" respectively, then \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{p,0}\"), \" or \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{q,0}\"), \" will contain a polynomial with a non-zero coefficient in \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"X^{-1}\"), \".  However \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"g^{\\\\tau^{-1}}\"), \" is not given out in the SRS and thus this cannot happen in the GGM.\"), mdx(\"p\", null, \"To prove that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_p\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathsf{com}_q\"), \" both have degree no higher than \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"m-1\"), \", the prover includes values \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{p,d}\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{q,d}\"), \" equal to\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"W_{p,d} = g^{ \\\\sum_{j=0}^{m-1} x_j \\\\tau^{j + d - m + 1 }} \\\\quad \\\\mbox{ and } \\\\quad W_{q,d} = g^{ \\\\sum_{j=0}^{m-1} y_j \\\\tau^{j + d - m + 1}}\"), mdx(\"p\", null, \"where \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"d\"), \" is the maximum power of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\tau\"), \" given out in the SRS.  The verifier checks  that\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \" e(\\\\mathsf{com}_p, h^{\\\\tau^{d - m + 1}}) = e(W_{p,d}, h)\\n\\\\quad \\\\mbox{ and }  \\\\quad e(\\\\mathsf{com}_q , h^{\\\\tau^{d - m + 1}}) = e(W_{q,d}, h).\"), mdx(\"p\", null, \"If these checks hold but \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(X)\"), \" or \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" have degree greater than \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"d\"), \", then \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{p,d}\"), \" or \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"W_{q,d}\"), \" will contain a polynomial with a non-zero coefficient of degree greater than \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"X^{d}\"), \".  However this is a higher power of tau than the maximum given out in the SRS and thus this cannot happen in the GGM.\"), mdx(\"p\", null, \"To prove that \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"p(X)\"), \" evaluates to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_1\"), \" at \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"q(X)\"), \" evaluates to \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"z_2\"), \" at \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"r\"), \", the prover computes KZG opening proofs. They set\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"\\\\omega_{p,r}(X) = \\\\frac{p(X) - z_1}{X - r} \\\\quad \\\\mbox{ and } \\\\quad \\\\omega_{q,r}(X) = \\\\frac{q(X) - z_2}{X - r}\"), mdx(\"p\", null, \"and compute\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"W_{p,r} = g^{ \\\\omega_{p,r}(\\\\tau)} \\\\quad \\\\mbox{ and } \\\\quad W_{q,r} = g^{ \\\\omega_{p,r}(\\\\tau)}.\"), mdx(\"p\", null, \"The verifier checks that\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"e(\\\\mathsf{com}_p  \\\\cdot g^{-z_1}, h) = e(W_{p,r}, h^{\\\\tau - r})\\n\\\\quad \\\\mbox{ and }  \\\\quad e(\\\\mathsf{com}_q  \\\\cdot g^{-z_2}, h) = e(W_{q,r}, h^{\\\\tau - r}).\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Efficiency:\"), \" The proof\"), mdx(\"div\", {\n    \"className\": \"math math-display\"\n  }, \"\\\\pi_{\\\\mathsf{inputs}} = (\\\\mathsf{com}_p, \\\\mathsf{com}_q, W_{p,0}, W_{q,0}, W_{p,d}, W_{q,d}, W_{p,r}, W_{q,r})\"), mdx(\"p\", null, \"consists of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"8\"), \" \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\mathbb{G}_1\"), \" elements. In  BLS12-381 this is \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"381\"), \" bytes. The verifier computes \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"12\"), \" pairings.  We have not optimised  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"\\\\pi_{\\\\mathsf{inputs}}\"), \" because it is not a  bottleneck, however there are some improvements that could be made in reducing the proof sizes and verifier time.\"), mdx(\"h3\", null, \"Some Preliminary Benchmarks\"), mdx(\"p\", null, \"We implement the VDF prover and verifier using the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/filecoin-project/bellperson/tree/master/src\"\n  }, \"Bellperson library\"), \" by Filecoin.  In the table below we give some benchmarks. These were computed on an Intel Core i5 with 2.3 GHz.\"), mdx(\"p\", null, \"The number of iterations of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" is the total number of times \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" is computed.  We use \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"n = 10000\"), \" for all benchmarks (the number of iterations proved per Groth16 prover) and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"m = 32, 64, 128, 256, 512, 1024\"), \" (the number of proofs aggregated).  This means the number of iterations of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" varies between \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"320,000\"), \" and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"10,240,000\"), \".  The  corresponding time to compute this many iterations of \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"f\"), \" is given in seconds.\"), mdx(\"p\", null, \"We  urge the reader not to take  the prover time too seriously because this is not indicative of the time taken by specialist hardware. Nonetheless we have provided the total proving time, in seconds, as the time to generate all Groth16 proofs and to generate the aggregation and public input proofs. We additionally give the time to generate the  aggregation and  public input proofs separately because these must wait until  the vdf completes before the prover can start.\"), mdx(\"p\", null, \"The verifier time is given in milliseconds.  It ranges between  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"58\"), \" ms and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"90\"), \" ms and is growing logarithmically.  This is as expected.\"), mdx(\"p\", null, \"The proof size is given in kilobytes.  This varies between  \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"17.1\"), \" kbytes and \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"29.0\"), \" kbytes and is growing logarithmically.\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"iterations of \", mdx(\"span\", {\n    parentName: \"th\",\n    \"className\": \"math math-inline\"\n  }, \"f\")), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"compute time (s)\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"total prove time (s)\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"aggregation prove time (s)\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"verify time (ms)\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"proof size (kbytes)\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"320,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3.5\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"43.2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"0.51\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"58\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"17.1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"640,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"6.8\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"85.7\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1.05\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"69\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"20.1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1,280,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"13.5\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"174.0\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1.87\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"75\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"23.1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2,560,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"27.4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"352.7\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3.72\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"79\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"26.1\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"5,120,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"54.4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"673.3\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"7.30\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"84\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"29.0\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"10,240,000\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"106.6\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1,357.9\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"14.55\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"90\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"32.0\")))), mdx(\"h2\", null, \"Some Estimated Benchmarks with ASICs and  Parallelism\"), mdx(\"p\", null, \"The following estimations were computed by Kelly Olson from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.supranational.net/\"\n  }, \"Supranational\"), \".\"), mdx(\"p\", null, \"In order to estimate the feasibility of using Sloth and SnarkPack as a production VDF, it is important to understand the potential performance of optimized implementations of the VDF evaluation and proof generation functions on alternative hardware platforms. First, in order to be secure and user friendly, VDF evaluation must be as fast as possible. Second, we can use a high degree of parallelism in generating the proofs.  With this in mind, we look to understand the complexity and time spent to generate a VDF proof using SnarkPack.\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=BXLcKQ6fLsU&t=4180s&ab_channel=StanfordVideo\"\n  }, \"Previous research\"), \" on RSA VDFs has shown that the performance of an ASIC can be up to 200x faster than a comparable CPU implementation.  However, since the modular multiplication operations in the BLS12-381 fields are much smaller than the 2048-bit operations in RSA groups, and therefore much closer to the native 64-bit word size of a modern CPU, we estimate that one round of the Sloth function could be performed in as little as 150 nanoseconds.  The baseline implementation took approximately 10 microseconds to evaluate a single iteration of the Sloth function, so with an ASIC we expect an approximate 70x speedup in computing the VDF.\"), mdx(\"p\", null, \"Let us assume arbitrary delay of one minute. While some use cases of VDFs may require a longer, or shorter, delay, the key point to understand is the relative performance between the evaluation and proving function. That is to say the proving must be sufficiently fast such that it does not add a significant amount of overhead on top of the evaluation function. In order to ensure a delay of at least one minute, approximately 425 million iterations of the Sloth function must be performed (assuming 150ns per iteration). Using the (3n+4) formula from above, this implies a total circuit complexity of approximately 1.27B constraints.\"), mdx(\"p\", null, \"To understand the time it would take to prove such a large circuit, we can look at implementations used in practice by projects such as Filecoin. One of the most common SNARKs used on the Filecoin blockchain is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=GRaR8N380h0&t=481s&ab_channel=ETHGlobal\"\n  }, \"Proof-of-Replication proof, which requires the generation of 10 Groth16 proofs\"), \", each of size approximately 130 million, for a total of 1.3B constraints. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://research.protocol.ai/sites/snarks/\"\n  }, \"Recent benchmarks\"), \" from the Filecoin community suggest that this proof can be created in <4 minutes using a modern CPU and GPU system. This implies a ratio of approximately 1:4 for VDF evaluation to proving time for the proposed function. However, since this VDF construction relies on generating many small proofs which are then aggregated, the proving operation can be easily parallelized by adding more proving hardware, such as a system with 4 GPUs, or by distributing the individual proof generation work across multiple \\u2018workers\\u2019. Given the increase in GPU performance from generation to generation, potential unexplored optimizations, and these high level estimates, it is feasible that a VDF system using the SnarkPack system could be used in a production environment today.\"), mdx(\"h2\", null, \"Acknowledgements\"), mdx(\"p\", null, \"Thanks to Kelly Olson for writing the estimated benchmarks above, Nicolas Gailly for his feedback and help navigating the Bellperson library, and to Dmitry Khovratovich for discussions on representing Minroot in R1CS.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"VDF Proving with SnarkPack Verifiable delay functions are a core building block to the Eth2 infrastructure.  They assume the existence of a…","color":"white","date":"16.07.2021","slug":"/blog/vdf-proving-with-snark-pack","title":"VDF Proving with SnarkPack","shortTitle":"SnarkPack VDF","category":"Still","cover":{"childImageSharp":{"resize":{"src":"/static/f30f79bad82d17bf2192cbe6d383c124/763c0/vdfsnail.jpg"}}}},"images":{"nodes":[{"name":"vdfsnail","childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/f30f79bad82d17bf2192cbe6d383c124/99adb/vdfsnail.jpg","srcSet":"/static/f30f79bad82d17bf2192cbe6d383c124/b049a/vdfsnail.jpg 318w,\n/static/f30f79bad82d17bf2192cbe6d383c124/93293/vdfsnail.jpg 636w,\n/static/f30f79bad82d17bf2192cbe6d383c124/99adb/vdfsnail.jpg 1272w","sizes":"(min-width: 1272px) 1272px, 100vw"},"sources":[{"srcSet":"/static/f30f79bad82d17bf2192cbe6d383c124/4b072/vdfsnail.webp 318w,\n/static/f30f79bad82d17bf2192cbe6d383c124/a47f2/vdfsnail.webp 636w,\n/static/f30f79bad82d17bf2192cbe6d383c124/c2515/vdfsnail.webp 1272w","type":"image/webp","sizes":"(min-width: 1272px) 1272px, 100vw"}]},"width":1600,"height":1323.2704402515724}}},{"name":"projects-bw-002","childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#d8d8d8","images":{"fallback":{"src":"/static/c48b187775749150cff5bb8e9b3d3d3e/25300/projects-bw-002.jpg","srcSet":"/static/c48b187775749150cff5bb8e9b3d3d3e/9d973/projects-bw-002.jpg 400w,\n/static/c48b187775749150cff5bb8e9b3d3d3e/f6ece/projects-bw-002.jpg 800w,\n/static/c48b187775749150cff5bb8e9b3d3d3e/25300/projects-bw-002.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/c48b187775749150cff5bb8e9b3d3d3e/aa378/projects-bw-002.webp 400w,\n/static/c48b187775749150cff5bb8e9b3d3d3e/4447d/projects-bw-002.webp 800w,\n/static/c48b187775749150cff5bb8e9b3d3d3e/c2596/projects-bw-002.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":1067}}},{"name":"projects-bw-001","childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/167104df3b4edce51cdde3230839521b/f3097/projects-bw-001.jpg","srcSet":"/static/167104df3b4edce51cdde3230839521b/c15a0/projects-bw-001.jpg 400w,\n/static/167104df3b4edce51cdde3230839521b/1de52/projects-bw-001.jpg 800w,\n/static/167104df3b4edce51cdde3230839521b/f3097/projects-bw-001.jpg 1600w","sizes":"(min-width: 1600px) 1600px, 100vw"},"sources":[{"srcSet":"/static/167104df3b4edce51cdde3230839521b/8b48a/projects-bw-001.webp 400w,\n/static/167104df3b4edce51cdde3230839521b/83e45/projects-bw-001.webp 800w,\n/static/167104df3b4edce51cdde3230839521b/35c27/projects-bw-001.webp 1600w","type":"image/webp","sizes":"(min-width: 1600px) 1600px, 100vw"}]},"width":1600,"height":2400}}}]}},"pageContext":{"slug":"/blog/vdf-proving-with-snark-pack","formatString":"DD.MM.YYYY","relativeDirectory":"vdf-proving-with-SnarkPack"}},
    "staticQueryHashes": ["1922044513","2744905544","318001574"]}